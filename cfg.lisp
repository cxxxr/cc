(in-package :cc)

(defstruct cfg nodes)
(defstruct cfg-node name code edges mark)

(defun find-cfg-node (name nodes)
  (let ((node (find name nodes :key #'cfg-node-name :test #'equal)))
    (assert (not (null node)))
    node))

(defun chain-cfg-node-edges (nodes tr-table)
  (loop :for (from . to) :in tr-table
        :do (let ((from-node (find-cfg-node from nodes)))
              (pushnew to (cfg-node-edges from-node)))))

(defun cfg-mark (nodes)
  (labels ((f (node)
             (unless (cfg-node-mark node)
               (setf (cfg-node-mark node) t)
               (dolist (edge (cfg-node-edges node))
                 (f (find-cfg-node edge nodes))))))
    (f (first nodes))))

(defun cfg-resolve-node-names (cfg)
  (let ((node-name-table (make-hash-table :test 'equal))
        (id 0))
    (dolist (node (cfg-nodes cfg))
      (let ((name (cfg-node-name node)))
        (setf (gethash name node-name-table) id)
        (setf (cfg-node-name node) id)
        (incf id)))
    (dolist (node (cfg-nodes cfg))
      (dolist (instr (cfg-node-code node))
        (trivia:match instr
          ((instr-jump arg1)
           (setf (instr-arg1 instr) (gethash arg1 node-name-table)))))))
  cfg)

(defun cfg-1 (fn)
  (let* ((current-node (make-cfg-node :name (gensym) :code '()))
         (nodes '())
         (tr-table))
    (labels ((next-node (name)
               (push-end current-node nodes)
               (setf current-node (make-cfg-node :name name :code '())))
             (append-code (instr)
               (push-end instr (cfg-node-code current-node)))
             (set-to-tr-table (to)
               (push-end (cons (cfg-node-name current-node) to) tr-table)))
      (dolist (instr (fn-code fn))
        (trivia:match instr
          ((instr-label arg1)
           (set-to-tr-table arg1)
           (next-node arg1))
          ((instr-jump arg1)
           (let ((next (gensym)))
             (append-code instr)
             (set-to-tr-table arg1)
             (when (typep instr 'instr-tjump)
               (set-to-tr-table next))
             (next-node next)))
          (_
           (append-code instr))))
      (next-node nil)
      (progn
        ;; mark & sweep
        (chain-cfg-node-edges nodes tr-table)
        (cfg-mark nodes)
        (setf nodes (delete nil nodes :key #'cfg-node-mark)))
      (let ((cfg (make-cfg :nodes nodes)))
        (setf (fn-code fn) cfg)
        (cfg-resolve-node-names cfg))))
  fn)

(defun cfg (fns)
  (mapcar #'cfg-1 fns))
