(in-package :cc)

(defstruct cfg nodes)
(defstruct cfg-node name code edges mark)

(defun find-cfg-node (name nodes)
  (let ((node (find name nodes :key #'cfg-node-name :test #'equal)))
    (assert (not (null node)))
    node))

(defun chain-cfg-node-edges (nodes tr-table)
  (loop :for (from . to) :in tr-table
        :do (let ((from-node (find-cfg-node from nodes)))
              (pushnew to (cfg-node-edges from-node)))))

(defun cfg-mark (nodes)
  (labels ((f (node)
             (setf (cfg-node-mark node) t)
             (dolist (edge (cfg-node-edges node))
               (f (find-cfg-node edge nodes)))))
    (f (first nodes))))

(defun cfg-1 (fn)
  (let* ((current-node (make-cfg-node :name 0 :code '()))
         (nodes '())
         (tr-table))
    (labels ((next-node (name)
               (push-end current-node nodes)
               (setf current-node (make-cfg-node :name name :code '())))
             (append-code (c)
               (push-end c (cfg-node-code current-node)))
             (set-to-tr-table (to)
               (push-end (cons (cfg-node-name current-node) to) tr-table)))
      (dolist (c (fn-code fn))
        (alexandria:destructuring-case c
          ((LABEL name)
           (set-to-tr-table name)
           (next-node name))
          (((JUMP TJUMP) name)
           (let ((next (gensym)))
             (append-code c)
             (set-to-tr-table name)
             (when (eq 'TJUMP (first c))
               (set-to-tr-table next))
             (next-node next)))
          ((t &rest rest)
           (declare (ignore rest))
           (append-code c))))
      (next-node nil)
      (chain-cfg-node-edges nodes tr-table)
      (cfg-mark nodes)
      (setf (fn-cfg fn)
            (make-cfg :nodes (delete nil nodes :key #'cfg-node-mark)))
      fn)))

(defun cfg (fns)
  (mapcar #'cfg-1 fns))
