(in-package :cc)

(defstruct cfg nodes)
(defstruct cfg-node name code edges mark)

(defun find-cfg-node (name nodes)
  (let ((node (find name nodes :key #'cfg-node-name :test #'equal)))
    (assert (not (null node)))
    node))

(defun chain-cfg-node-edges (nodes tr-table)
  (loop :for (from . to) :in tr-table
        :do (let ((from-node (find-cfg-node from nodes)))
              (pushnew to (cfg-node-edges from-node)))))

(defun cfg-mark (nodes)
  (labels ((f (node)
             (unless (cfg-node-mark node)
               (setf (cfg-node-mark node) t)
               (dolist (edge (cfg-node-edges node))
                 (f (find-cfg-node edge nodes))))))
    (f (first nodes))))

(defun cfg-1 (fn)
  (let* ((current-node (make-cfg-node :name (gensym) :code '()))
         (nodes '())
         (tr-table))
    (labels ((next-node (name)
               (push-end current-node nodes)
               (setf current-node (make-cfg-node :name name :code '())))
             (append-code (instr)
               (push-end instr (cfg-node-code current-node)))
             (set-to-tr-table (to)
               (push-end (cons (cfg-node-name current-node) to) tr-table)))
      (dolist (instr (fn-code fn))
        (trivia:match instr
          ((instr-label arg1)
           (set-to-tr-table arg1)
           (next-node arg1))
          ((instr-jump arg1)
           (let ((next (gensym)))
             (append-code instr)
             (set-to-tr-table arg1)
             (when (typep instr 'instr-tjump)
               (set-to-tr-table next))
             (next-node next)))
          (_
           (append-code instr))))
      (next-node nil)
      (chain-cfg-node-edges nodes tr-table)
      (cfg-mark nodes)
      (setf (fn-cfg fn)
            (make-cfg :nodes (delete nil nodes :key #'cfg-node-mark)))
      fn)))

(defun cfg (fns)
  (mapcar #'cfg-1 fns))
